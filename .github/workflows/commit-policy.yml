# GitHub Actions workflow to enforce semantic commit message policy.
# This workflow validates that all commit messages follow the required format.
# Works in conjunction with the local Git hook for comprehensive validation.

name: Commit Policy

# Trigger on all pull requests and pushes to any branch.
# This ensures commit message validation across all development activity.
on:
  pull_request: # Validate PR commits before they reach master.
  push: # Validate direct pushes to any branch.

env:
  # Cutoff date for semantic commit enforcement (ISO 8601 format: YYYY-MM-DD).
  # Commits before this date are exempt from validation (legacy commits).
  # Update this date when you start enforcing semantic commits in your project.
  SEMANTIC_COMMIT_CUTOFF_DATE: "2025-01-01"

jobs:
  validate-commit-messages:
    runs-on: ubuntu-latest # Use Ubuntu for consistent bash behavior.
    steps:
      # Check out repository with full Git history for commit analysis.
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0 # Fetch all history to access commit ranges.

      # Check if this is a fork PR or Dependabot PR (external contributor/automation).
      # Fork PRs and Dependabot PRs are exempt from semantic commit rules.
      - name: Check if fork or Dependabot PR
        id: fork_check
        run: |
          # Check if this is a Dependabot PR.
          if [[ "${{ github.actor }}" == "dependabot[bot]" ]]; then
            echo "is_fork=true" >> "$GITHUB_OUTPUT"
            echo "This is a Dependabot PR (automated dependency update)."
            echo "Semantic commit validation will be skipped."
            echo "Dependabot uses its own commit format: build(deps): ..."
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            IS_FORK="${{ github.event.pull_request.head.repo.fork }}"
            echo "is_fork=$IS_FORK" >> "$GITHUB_OUTPUT"
            if [[ "$IS_FORK" == "true" ]]; then
              echo "This is a fork PR (external contributor)."
              echo "Semantic commit validation will be skipped."
              echo "Changes will be treated as 'fix:' (patch) by default."
            else
              echo "This is an internal PR or direct push."
              echo "Semantic commit validation will be enforced."
            fi
          else
            echo "is_fork=false" >> "$GITHUB_OUTPUT"
            echo "This is a direct push (not a PR)."
            echo "Semantic commit validation will be enforced."
          fi

      # Determine the range of commits to validate based on event type.
      # Different logic for PRs vs direct pushes to handle Git refs correctly.
      - name: Determine range
        if: steps.fork_check.outputs.is_fork != 'true'
        id: range
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For PRs: check commits between base branch and PR head.
            echo "range=${{ github.event.pull_request.base.sha }}..${{ github.sha }}" >> "$GITHUB_OUTPUT"
          else
            # For push events: use GitHub-provided before..after range.
            # Handle edge case where before is all zeros (new branch).
            if [[ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]]; then
              echo "range=${{ github.sha }}" >> "$GITHUB_OUTPUT"
            else
              echo "range=${{ github.event.before }}..${{ github.sha }}" >> "$GITHUB_OUTPUT"
            fi
          fi

      # Validate that all commits in the range follow semantic commit format.
      # Enforces the same rules as the local Git hook: fix:, feat:, major:.
      - name: Check commit messages
        if: steps.fork_check.outputs.is_fork != 'true'
        run: |
          set -euo pipefail  # Exit on error, undefined variables, pipe failures.
          range='${{ steps.range.outputs.range }}'
          cutoff_date='${{ env.SEMANTIC_COMMIT_CUTOFF_DATE }}'

          # Define the required commit message pattern (matches Git hook).
          pattern='^(fix|feat|major): '
          
          # List of trusted external contributors (bots and automation).
          trusted_authors=("dependabot[bot]" "github-actions[bot]")

          # Check if the range is valid (may be invalid after force push).
          # If invalid, validate just the current commit instead.
          if ! git rev-parse "$range" >/dev/null 2>&1; then
            echo "Commit range is invalid (likely due to force push)."
            echo "Validating current commit only: ${{ github.sha }}"
            range="${{ github.sha }}"
          else
            echo "Checking commits in range: $range"
          fi

          echo "Semantic commit cutoff date: $cutoff_date"
          echo "Commits before this date will be automatically approved."
          echo ""

          # Extract commit data: hash, author, date, subject.
          # Format: <hash>|<author>|<date>|<subject>
          commit_data=$(git log --format="%H|%an|%aI|%s" "$range" 2>/dev/null || git log --format="%H|%an|%aI|%s" -1 "${{ github.sha }}")

          # Handle edge case where no commits exist in range.
          if [[ -z "$commit_data" ]]; then
            echo "No commits to check (range may be empty)."; exit 0
          fi

          # Filter commits: exclude those before cutoff date and from trusted authors.
          filtered_commits=""
          excluded_count=0
          
          while IFS='|' read -r hash author date subject; do
            # Extract date part (YYYY-MM-DD) from ISO 8601 timestamp.
            commit_date="${date:0:10}"
            
            # Check if commit is from a trusted author.
            is_trusted=false
            for trusted in "${trusted_authors[@]}"; do
              if [[ "$author" == "$trusted" ]]; then
                is_trusted=true
                echo "✓ Trusted author: $author - $subject"
                ((excluded_count++))
                break
              fi
            done
            
            if [[ "$is_trusted" == true ]]; then
              continue
            fi
            
            # Check if commit is before cutoff date.
            if [[ "$commit_date" < "$cutoff_date" ]]; then
              echo "✓ Legacy commit ($commit_date): $subject"
              ((excluded_count++))
              continue
            fi
            
            # Add to filtered list for validation.
            if [[ -z "$filtered_commits" ]]; then
              filtered_commits="$subject"
            else
              filtered_commits="$filtered_commits"$'\n'"$subject"
            fi
          done <<< "$commit_data"

          echo ""
          echo "Total commits in range: $(echo "$commit_data" | wc -l)"
          echo "Excluded commits (legacy/trusted): $excluded_count"
          echo "Commits to validate: $(if [[ -n "$filtered_commits" ]]; then echo "$filtered_commits" | wc -l; else echo "0"; fi)"
          echo ""

          # If no commits need validation, we're done.
          if [[ -z "$filtered_commits" ]]; then
            echo "All commits are either legacy or from trusted authors."
            echo "No validation needed. ✓"
            exit 0
          fi

          # Check if ANY commit follows semantic versioning.
          semantic_commits=$(printf '%s\n' "$filtered_commits" | grep -E "$pattern" || true)

          if [[ -n "$semantic_commits" ]]; then
            # Found semantic commits - validate ALL commits must follow pattern.
            bad=$(printf '%s\n' "$filtered_commits" | grep -Ev "$pattern" || true)
            
            if [[ -n "$bad" ]]; then
              echo '❌ Mixed commit types detected. If using semantic commits, ALL commits must follow the pattern:'
              echo "$bad"
              echo
              echo "Allowed prefixes: 'fix: ', 'feat: ', 'major: '"
              exit 1
            fi
            
            echo "✓ All commits follow semantic versioning pattern."
          else
            # No semantic commits found - treat as automatic dependency updates (fix).
            echo "No semantic commits found. Treating as automatic updates (fix: dependency maintenance)."
            echo "Commits in this push:"
            printf '%s\n' "$filtered_commits" | sed 's/^/  - /'
          fi

          echo ""
          echo "✓ All commit messages conform to policy."

      # Acknowledge fork PRs and Dependabot PRs and explain the policy.
      # External contributors and automated tools don't need to follow semantic commit rules.
      - name: Fork/Dependabot PR acknowledgment
        if: steps.fork_check.outputs.is_fork == 'true'
        run: |
          if [[ "${{ github.actor }}" == "dependabot[bot]" ]]; then
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo " Dependabot PR detected"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            echo "This is an automated dependency update from Dependabot."
            echo "Semantic commit validation has been skipped."
            echo "Dependabot uses its own commit format: build(deps): ..."
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          else
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo " Thank you for your contribution!"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            echo "This is a fork PR from an external contributor."
            echo "Semantic commit validation has been skipped."
            echo "Your changes will be treated as a patch (fix:) by default."
            echo ""
            echo "The maintainer will decide the final version bump when merging."
            echo "Feel free to use any commit message format you're comfortable with!"
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          fi
